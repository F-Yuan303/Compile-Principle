#include <iostream> #include <stdlib.h> using namespace std; #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 typedef int Elemtype; typedef struct{ Elemtype *elem; int length; int listsize; }SqList; int InitList_Sq(SqList &L) //初始化 { L.elem = (Elemtype *) malloc(LIST_INIT_SIZE * sizeof(Elemtype)); if (!L.elem) { cout<<"构造失败！\n"; exit(OVERFLOW); } L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; } void ListInsert_Sq(SqList &L, Elemtype e) //插入元素 { Elemtype *newbase, *q; if(L.length >= L.listsize) { newbase=(Elemtype *)realloc(L.elem, (L.listsize +10) * sizeof (Elemtype)); if(!newbase) exit(OVERFLOW); L.elem = newbase; L.listsize += LISTINCREMENT; } q = L.elem + L.length; *q = e; L.length ++; } int ListTraverse_Sq(SqList L) //输出在屏幕上 { Elemtype *p, i; p = L.elem; if(L.length == 0) { cout<<"表中无元素！"<<endl; return ERROR; } for(i = 0; i<L.length; i++ ) cout << *(p+i) << " "; return OK; } int CreateList_Sq(SqList &L, Elemtype n) //创建顺序表 { InitList_Sq(L); Elemtype i,e; cout << "请输入这些元素："; for (i = 0;i < n; i++) { cin >> e; ListInsert_Sq(L,e); } return OK; } int Partition(SqList &L, int low, int high) //快速排序 { int key; key = L.elem[low]; while (low < high) { while (low < high && L.elem[high] >= key) high--; L.elem[low] = L.elem[high]; while (low < high && L.elem[low] <= key) low++; L.elem[high] = L.elem[low]; } L.elem[low] = key; return low; } void Qsort(SqList &L, int low, int high) { int pivotloc; if (low<high) { pivotloc = Partition(L,low,high); Qsort(L,low,pivotloc-1); Qsort(L,pivotloc+1,high); } } void QuikSort(SqList &L) { Qsort(L,0,L.length-1); } int main() { SqList L; int n; cout << "请输入个数："; cin >> n; CreateList_Sq(L,n); QuikSort(L); ListTraverse_Sq(L); return 0; } 